#include <assert.h>

// Generate mask indicating leftmost 1 in x.
// Assume = 32.
// For example: 0xFF00 -> 0x8000, and 0x6600 -> 0x4000.
// If x = 0, then return 0.
// 保留x最左边为1的位，其余为都置为0
// 0xFF00的二进制为[1111 1111 0000 0000]
// 保留最左边的位为[1000 0000 0000 0000]即0x8000
unsigned leftmost_one(unsigned x) {

    // 从最左边开始使用|将最左边为1的位后的所有位设置为1
    // 假如m第i位为1，将m右移1位和m取或则第i,i-1位都为1
    // 此时m的第i,i-1位都为1，将m右移2位取或则i,i-1,i-2,i-3都为1
    // 重复直到所有的位都为1，即右移位数为m的长度的一半时，i后的所有位都为1
    // 比如：[0001 0000]
    // [0001 0000] >> 1 = [0000 1000] | [0001 0000] = [0001 1000]
    // [0001 1000] >> 2 = [0000 0110] | [0001 1000] = [0001 1110]
    // [0001 1110] >> 4 = [0000 0001] | [0001 1110] = [0001 1111] 
    // 将结果向>>1，则除了最高为1的位，其余位都相同
    // 使用^将相同的位消除则留下的位最左边为1的位
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);

    return (x ^ (x >> 1));
}

int main() {
    assert(leftmost_one(0xFF00) == 0x8000);
    assert(leftmost_one(0x6000) == 0x4000);
    assert(leftmost_one(0x0) == 0x0);
    assert(leftmost_one(0x80000000) == 0x80000000);
    return 0;
}